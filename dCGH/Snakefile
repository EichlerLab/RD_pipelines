import glob
import gzip
import io
import random
import math
from datetime import date
import time
import os

"""
BEGIN CONSTANTS
"""

SNAKEMAKE_DIR = os.path.dirname(workflow.snakefile)

SSF_DIR = SNAKEMAKE_DIR + "/../ssf_DTS_caller"

CUTOFF_SCALE=3000
WINDOW_SIZE=500
MAX_MERGE_DIF=0.27

if config == {}:
    configfile: "%s/config.yaml" % SNAKEMAKE_DIR

shell.prefix("source %s/../env.conf; export PYTHONPATH=%s/../wssd_sunk:$PYTHONPATH; " % (SNAKEMAKE_DIR, SNAKEMAKE_DIR))

DUP_TABIX = config["dup_tabix"]
GENE_TABIX = config["gene_tabix"]
GC_TABIX = config["gc_tabix"]

P_CUTOFF = config["p_cutoff"]

DTS_DIR = config["dts_dir"]
DTS_REF_DIR = config["dts_ref_dir"]
GGLOB_DIR = config["gglob_dir"]

WND_CONTIGS = config["wnd_contigs"]
GAPS = config["gaps"]

"""
Begin TEST_CALL_FILTER section.
Run initially with TEST_CALL_FILTER set to True, then check call plots in plot directory. 
Once you are satisfied with the calls, run 
snakemake clean_call_filter_test 
then run the Snakefile with TEST_CALL_FILTER set to False. 

This section modifies how rule genotype_refine_breakpoints_by_chr_subset is run.
"""

TEST_CALL_FILTER = False

if TEST_CALL_FILTER:
    CONTIGS=["chr20"]
    PLOT_MODE="--do_plot"
    #PLOT_MODE=""
else:
    CONTIGS=["chr%d" % d for d in range(1,23)]
    PLOT_MODE=""

"""End TEST_CALL_FILTER section"""

DTS_PREFIX="500_bp_"

samples=[s.split("/")[-1].replace(DTS_PREFIX,"") for s in glob.glob("%s/*"%DTS_DIR)]

N_SUBSETS=100
SUBSETS=range(N_SUBSETS)

references=[x.replace(DTS_PREFIX, "") for x in os.listdir(DTS_REF_DIR)]

EXCLUDE=[]

samples=list(set(samples)-set(EXCLUDE))

"""
END CONSTANTS
"""

"""
LOAD MODULES, SET PYTHONPATH, AND CREATE INITIAL DIRECTORIES
"""

DIRS_TO_MAKE = ["log", "plot"]

for folder in DIRS_TO_MAKE:
    if not os.path.exists(folder):
        os.makedirs(folder)

datestr = "%d%.2d%.2d_%s"%(date.today().year,date.today().month,date.today().day, time.strftime('%H%M%S'))

localrules: all

rule all:
    input: "final_calls/final_calls.bed","final_calls/final_genotypes", "beds_resolved_calls/all.bed","final_calls/analysis_callsets/bi_allelic_genotypes", "final_calls/final_calls.vcf"

rule plot_call_size_distribution:
    input: "final_calls/final_calls.bed"
    output: "call_size.hist.gt100kbp.pdf", "call_size.hist.lt100kbp.pdf"
    params: sge_opts="-l h_rt=0:5:00"
    run:
        import matplotlib as mpl
        mpl.use("Agg")
        import matplotlib.pyplot as plt
        import pandas as pd
        import seaborn as sns

        dat = pd.read_table(input[0], header=None)
        dat.columns = ["chr", "start", "end"]
        dat["Call size"] = dat.end - dat.start
        sns.distplot(dat["Call size"][dat["Call size"] >= 100000], bins=100, kde=False, axlabel="Call size (>100 kbp)")
        plt.savefig(output[0])
        plt.clf()
        sns.distplot(dat["Call size"][dat["Call size"] < 100000], bins=100, kde=False, axlabel="Call size (<100 kbp)")
        plt.savefig(output[1])

rule split_calls_by_type:
    input: "final_calls/final_genotypes"
    output: "final_calls/final_calls.DEL.tab", "final_calls/final_calls.DUP.tab", "final_calls/final_calls.mCNV.tab"
    params: sge_opts="-l mfree=8G"
    run:
        dels = open(output[0], "w")
        dups = open(output[1], "w")
        mcnvs = open(output[2], "w")

        with open(input[0], "r") as infile:
            for i, line in enumerate(infile):
                nsamples = 0
                if i == 0:
                    dels.write(line)
                    dups.write(line)
                    mcnvs.write(line)
                    nsamples = len(line.rstrip().split()) - 3
                    continue
                cps = list(map(int, line.rstrip().split()[3:]))
                if all([x in [0, 1, 2] for x in cps]):
                    dels.write(line)
                elif all([x in [2, 3, 4] for x in cps]):
                    dups.write(line)
                else:
                    mcnvs.write(line)
        dels.close()
        dups.close()
        mcnvs.close()

rule export_callset:
    input: "final_calls/final_calls.bed","final_calls/final_genotypes", "beds_resolved_calls/all.bed","final_calls/analysis_callsets/bi_allelic_genotypes", "final_calls/final_calls.vcf.gz", "final_calls/final_calls.filter_data"    
    output: "exported_callsets/%s/final_calls.bed"%datestr
    params: outdir="exported_callsets/%s"%(datestr), sge_opts="-l h_rt=0:30:00"
    shell: "cp {input} {params.outdir}"

rule make_table_of_simple_genotypes:
    input: "final_calls/final_genotypes"
    output: "final_calls/analysis_callsets/bi_allelic_genotypes"
    params:  sge_opts="-l mfree=2G -N combine_contigs -l h_rt=1:00:00", exclude=":".join(EXCLUDE)
    benchmark: "benchmarks_dCGH/get_biallelic_dels.txt"
    shell: "python {SSF_DIR}/filter_to_simple_gts.py --fn_gts {input} --fn_out {output} --exclude params.exclude"

rule make_final_vcf:
    input: expand("final_calls/by_chr/{contig}/{k}.vcf",contig=CONTIGS, k=SUBSETS)
    output: "final_calls/final_calls.vcf"
    params: sge_opts="-l mfree=4G -l h_rt=1:0:0"
    benchmark: "benchmarks_dCGH/make_final_vcf.txt"
    shell:
        "module load vcflib/20160331; vcfcombine {input} | vcfstreamsort > {output}"

rule combine_by_chr:
    input: expand("final_calls/by_chr/{contig}/{k}.genotypes",contig=CONTIGS, k=SUBSETS)
    output: "final_calls/final_genotypes", "final_calls/final_calls.bed","final_calls/final_calls.filter_data"  
    params:  sge_opts="-l mfree=2G -N combine_contigs -l h_rt=0:30:00"
    benchmark: "benchmarks_dCGH/combine_by_chr.txt"
    run:
        FOUT_gts = open(output[0], 'w')
        FOUT_bed = open(output[1], 'w')
        FOUT_filt = open(output[2], 'w')
        
        h_gts = open(input[0]).readline()
        h_filt = open(input[0].replace(".genotypes",".bed.info")).readline()

        FOUT_gts.write(h_gts)
        FOUT_filt.write(h_filt)

        for fn_i in input:
            FIN_gts = open(fn_i)
            FIN_bed = open(fn_i.replace(".genotypes",".bed"))
            FIN_filt = open(fn_i.replace(".genotypes",".bed.info"))
            
            h  = FIN_gts.readline()
            for l in FIN_gts:
                FOUT_gts.write(l)
            
            h  = FIN_filt.readline()
            for l in FIN_filt:
                FOUT_filt.write(l)

            for l in FIN_bed:
                FOUT_bed.write(l)
                
        FOUT_bed.close()
        FOUT_filt.close()
        FOUT_gts.close()

rule clean_call_filter_test:
    input: "final_calls/by_chr/{contig}/{k}.genotypes", "final_calls/by_chr/{contig}/{k}.bed", "final_calls/by_chr/{contig}/{k}.vcf"
    params: contig = '{contig}', sge_opts="-l h_rt=1:00"
    shell: "rm -rf final_calls/by_chr/{params.contig}/*"

rule genotype_refine_breakpoints_by_chr_subset:
    input: "all_resolved_calls/all_resolved_calls.gz"
    output: "final_calls/by_chr/{contig}/{k}.genotypes", "final_calls/by_chr/{contig}/{k}.bed", "final_calls/by_chr/{contig}/{k}.vcf"
    params: contig="{contig}", 
            sge_opts="-l mfree=20G -N {contig}_{k}_genotyping -l h_rt=5:00:00", 
            curr_n="{k}", 
            plot_out_dir="final_calls/by_chr/{contig}",
            subset_gglob_indivs=":".join([s.split("/")[-1] for s in samples])
    benchmark: "benchmarks_dCGH/genotype_refine.{contig}.{k}.txt"
    shell: "python {SSF_DIR}/genotype_refined_call_sets.py --call_table {input} --dup_tabix {DUP_TABIX} --genotype_output {output[0]} --vcf_output {output[2]} --call_output {output[1]} --contig {params.contig} --visualizations_dir {params.plot_out_dir} --gglob_dir {GGLOB_DIR} --total_subsets {N_SUBSETS} --subset {params.curr_n} --subset_indivs {params.subset_gglob_indivs} {PLOT_MODE}"


